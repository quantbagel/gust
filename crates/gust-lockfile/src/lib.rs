//! Lockfile handling for Gust.
//!
//! Manages Gust.lock files for reproducible builds.
//! Supports incremental updates to minimize I/O and diff computation.

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use gust_types::{DependencySource, Version};
use thiserror::Error;
use tokio::sync::Mutex;

#[derive(Error, Debug)]
pub enum LockfileError {
    #[error("Failed to read lockfile: {0}")]
    ReadError(#[from] std::io::Error),
    #[error("Failed to parse lockfile: {0}")]
    ParseError(#[from] toml::de::Error),
    #[error("Failed to serialize lockfile: {0}")]
    SerializeError(#[from] toml::ser::Error),
    #[error("Async task error: {0}")]
    TaskError(String),
}

/// A Gust lockfile.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lockfile {
    /// Lockfile format version
    pub version: u32,
    /// Tool that generated this lockfile
    #[serde(rename = "generated-by")]
    pub generated_by: String,
    /// Locked packages
    #[serde(rename = "package", default)]
    pub packages: Vec<LockedPackage>,
}

impl Default for Lockfile {
    fn default() -> Self {
        Self {
            version: 1,
            generated_by: format!("gust {}", env!("CARGO_PKG_VERSION")),
            packages: Vec::new(),
        }
    }
}

impl Lockfile {
    /// Load a lockfile from disk.
    pub fn load(path: &Path) -> Result<Self, LockfileError> {
        let content = fs::read_to_string(path)?;
        let lockfile: Lockfile = toml::from_str(&content)?;
        Ok(lockfile)
    }

    /// Save the lockfile to disk.
    pub fn save(&self, path: &Path) -> Result<(), LockfileError> {
        let header = "# This file is auto-generated by Gust\n# Do not edit manually\n\n";
        let content = toml::to_string_pretty(self)?;
        fs::write(path, format!("{}{}", header, content))?;
        Ok(())
    }

    /// Check if the lockfile exists.
    pub fn exists(path: &Path) -> bool {
        path.exists()
    }

    /// Get a locked package by name.
    pub fn get(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name)
    }

    /// Add or update a locked package.
    pub fn upsert(&mut self, package: LockedPackage) {
        if let Some(existing) = self.packages.iter_mut().find(|p| p.name == package.name) {
            *existing = package;
        } else {
            self.packages.push(package);
        }
    }

    /// Build a lookup map for quick access.
    pub fn as_map(&self) -> HashMap<String, &LockedPackage> {
        self.packages.iter().map(|p| (p.name.clone(), p)).collect()
    }

    /// Compute the difference between this lockfile and another.
    pub fn diff(&self, other: &Lockfile) -> LockfileDiff {
        let self_map: HashMap<_, _> = self.packages.iter().map(|p| (&p.name, p)).collect();
        let other_map: HashMap<_, _> = other.packages.iter().map(|p| (&p.name, p)).collect();

        let mut added = Vec::new();
        let mut removed = Vec::new();
        let mut updated = Vec::new();
        let mut unchanged = Vec::new();

        // Find added and updated packages
        for (name, pkg) in &other_map {
            if let Some(existing) = self_map.get(name) {
                if pkg.revision != existing.revision || pkg.version != existing.version {
                    updated.push((*pkg).clone());
                } else {
                    unchanged.push((*name).clone());
                }
            } else {
                added.push((*pkg).clone());
            }
        }

        // Find removed packages
        for name in self_map.keys() {
            if !other_map.contains_key(name) {
                removed.push((*name).clone());
            }
        }

        LockfileDiff {
            added,
            removed,
            updated,
            unchanged,
        }
    }

    /// Apply a diff to create an updated lockfile.
    pub fn apply_diff(&self, diff: &LockfileDiff) -> Lockfile {
        let removed_set: HashSet<_> = diff.removed.iter().collect();

        let mut new_packages: Vec<LockedPackage> = self
            .packages
            .iter()
            .filter(|p| !removed_set.contains(&p.name))
            .cloned()
            .collect();

        // Apply updates
        for updated in &diff.updated {
            if let Some(pkg) = new_packages.iter_mut().find(|p| p.name == updated.name) {
                *pkg = updated.clone();
            }
        }

        // Add new packages
        new_packages.extend(diff.added.iter().cloned());

        // Sort for deterministic output
        new_packages.sort_by(|a, b| a.name.cmp(&b.name));

        Lockfile {
            version: self.version,
            generated_by: format!("gust {}", env!("CARGO_PKG_VERSION")),
            packages: new_packages,
        }
    }

    /// Merge with new resolution, returning the diff and updated lockfile.
    pub fn merge(&self, new_packages: Vec<LockedPackage>) -> (LockfileDiff, Lockfile) {
        let new_lockfile = Lockfile {
            version: self.version,
            generated_by: format!("gust {}", env!("CARGO_PKG_VERSION")),
            packages: new_packages,
        };

        let diff = self.diff(&new_lockfile);
        let merged = self.apply_diff(&diff);

        (diff, merged)
    }

    /// Save the lockfile asynchronously (non-blocking).
    pub async fn save_async(&self, path: PathBuf) -> Result<(), LockfileError> {
        let content = self.to_string()?;

        tokio::task::spawn_blocking(move || fs::write(&path, content))
            .await
            .map_err(|e| LockfileError::TaskError(e.to_string()))?
            .map_err(LockfileError::ReadError)
    }

    /// Serialize to string.
    pub fn to_string(&self) -> Result<String, LockfileError> {
        let header = "# This file is auto-generated by Gust\n# Do not edit manually\n\n";
        let content = toml::to_string_pretty(self)?;
        Ok(format!("{}{}", header, content))
    }

    /// Check if the lockfile needs updating compared to a new resolution.
    pub fn needs_update(&self, new_packages: &[LockedPackage]) -> bool {
        if self.packages.len() != new_packages.len() {
            return true;
        }

        let self_map: HashMap<_, _> = self.packages.iter().map(|p| (&p.name, p)).collect();

        for pkg in new_packages {
            match self_map.get(&pkg.name) {
                None => return true,
                Some(existing) => {
                    if existing.revision != pkg.revision || existing.version != pkg.version {
                        return true;
                    }
                }
            }
        }

        false
    }
}

/// Represents the difference between two lockfiles.
#[derive(Debug, Clone, Default)]
pub struct LockfileDiff {
    /// Packages that were added
    pub added: Vec<LockedPackage>,
    /// Package names that were removed
    pub removed: Vec<String>,
    /// Packages that were updated
    pub updated: Vec<LockedPackage>,
    /// Package names that are unchanged
    pub unchanged: Vec<String>,
}

impl LockfileDiff {
    /// Check if there are any changes.
    pub fn has_changes(&self) -> bool {
        !self.added.is_empty() || !self.removed.is_empty() || !self.updated.is_empty()
    }

    /// Get total number of changes.
    pub fn change_count(&self) -> usize {
        self.added.len() + self.removed.len() + self.updated.len()
    }

    /// Format a summary of changes.
    pub fn summary(&self) -> String {
        let mut parts = Vec::new();

        if !self.added.is_empty() {
            parts.push(format!("+{}", self.added.len()));
        }
        if !self.removed.is_empty() {
            parts.push(format!("-{}", self.removed.len()));
        }
        if !self.updated.is_empty() {
            parts.push(format!("~{}", self.updated.len()));
        }

        if parts.is_empty() {
            "no changes".to_string()
        } else {
            parts.join(", ")
        }
    }
}

/// Async lockfile writer that batches writes.
pub struct AsyncLockfileWriter {
    path: PathBuf,
    pending: Arc<Mutex<Option<Lockfile>>>,
}

impl AsyncLockfileWriter {
    /// Create a new async writer.
    pub fn new(path: PathBuf) -> Self {
        Self {
            path,
            pending: Arc::new(Mutex::new(None)),
        }
    }

    /// Queue a lockfile for writing.
    pub async fn queue(&self, lockfile: Lockfile) {
        let mut pending = self.pending.lock().await;
        *pending = Some(lockfile);
    }

    /// Flush any pending writes.
    pub async fn flush(&self) -> Result<bool, LockfileError> {
        let lockfile = {
            let mut pending = self.pending.lock().await;
            pending.take()
        };

        if let Some(lf) = lockfile {
            lf.save_async(self.path.clone()).await?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Write immediately without queueing.
    pub async fn write_now(&self, lockfile: Lockfile) -> Result<(), LockfileError> {
        lockfile.save_async(self.path.clone()).await
    }
}

/// A locked package entry.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedPackage {
    /// Package name
    pub name: String,
    /// Exact locked version
    pub version: Version,
    /// Source type
    pub source: DependencySource,
    /// Content checksum (BLAKE3)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,
    /// Git URL (for git dependencies)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub git: Option<String>,
    /// Git revision (for git dependencies)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revision: Option<String>,
    /// Transitive dependencies
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dependencies: Vec<String>,
}

impl LockedPackage {
    /// Create a new locked package from registry.
    pub fn registry(name: impl Into<String>, version: Version, checksum: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            version,
            source: DependencySource::Registry,
            checksum: Some(checksum.into()),
            git: None,
            revision: None,
            dependencies: Vec::new(),
        }
    }

    /// Create a new locked package from git.
    pub fn git(
        name: impl Into<String>,
        version: Version,
        url: impl Into<String>,
        revision: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            version,
            source: DependencySource::Git,
            checksum: None,
            git: Some(url.into()),
            revision: Some(revision.into()),
            dependencies: Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lockfile_serialization() {
        let mut lockfile = Lockfile::default();
        lockfile.upsert(LockedPackage::registry(
            "swift-log",
            Version::new(1, 5, 4),
            "blake3:abc123",
        ));

        let toml = toml::to_string_pretty(&lockfile).unwrap();
        assert!(toml.contains("swift-log"));
        assert!(toml.contains("1.5.4"));
    }
}
