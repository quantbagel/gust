//! Package.swift generation from Gust manifests.

use gust_types::{Dependency, Manifest, Target, TargetType};
use std::path::Path;

/// Generate a Package.swift file from a Gust manifest.
pub fn generate_package_swift(manifest: &Manifest) -> String {
    let mut out = String::new();

    // Swift tools version
    out.push_str(&format!(
        "// swift-tools-version:{}\n",
        manifest.package.swift_tools_version
    ));

    // Header comment
    out.push_str("// This file is auto-generated by Gust. Do not edit manually.\n");
    out.push_str("// To modify dependencies, edit Gust.toml instead.\n\n");

    out.push_str("import PackageDescription\n\n");
    out.push_str("let package = Package(\n");
    out.push_str(&format!("    name: \"{}\",\n", manifest.package.name));

    // Platforms (if specified)
    generate_platforms(&mut out, manifest);

    // Products
    generate_products(&mut out, manifest);

    // Dependencies
    generate_dependencies(&mut out, manifest);

    // Targets
    generate_targets(&mut out, manifest);

    out.push_str(")\n");
    out
}

fn generate_platforms(out: &mut String, manifest: &Manifest) {
    if manifest.platforms.is_empty() {
        return;
    }

    out.push_str("    platforms: [\n");

    // Sort platforms for consistent output
    let mut platforms: Vec<_> = manifest.platforms.iter().collect();
    platforms.sort_by_key(|(k, _)| *k);

    for (platform, version) in platforms {
        let swift_platform = match platform.to_lowercase().as_str() {
            "macos" => ".macOS",
            "ios" => ".iOS",
            "tvos" => ".tvOS",
            "watchos" => ".watchOS",
            "visionos" => ".visionOS",
            "linux" => continue, // Linux doesn't have version requirements in Package.swift
            other => {
                // Try to use the platform name as-is with proper casing
                out.push_str(&format!(
                    "        // Unsupported platform: {} {}\n",
                    other, version
                ));
                continue;
            }
        };
        out.push_str(&format!(
            "        {}(.v{}),\n",
            swift_platform,
            version.replace('.', "_")
        ));
    }

    out.push_str("    ],\n");
}

fn generate_products(out: &mut String, manifest: &Manifest) {
    let has_library = manifest
        .targets
        .iter()
        .any(|t| t.target_type == TargetType::Library);
    let has_executable = manifest
        .targets
        .iter()
        .any(|t| t.target_type == TargetType::Executable);

    if has_library || has_executable {
        out.push_str("    products: [\n");

        for target in &manifest.targets {
            match target.target_type {
                TargetType::Library => {
                    out.push_str(&format!(
                        "        .library(name: \"{}\", targets: [\"{}\"]),\n",
                        target.name, target.name
                    ));
                }
                TargetType::Executable => {
                    out.push_str(&format!(
                        "        .executable(name: \"{}\", targets: [\"{}\"]),\n",
                        target.name, target.name
                    ));
                }
                _ => {}
            }
        }

        out.push_str("    ],\n");
    }
}

fn generate_dependencies(out: &mut String, manifest: &Manifest) {
    if manifest.dependencies.is_empty() {
        return;
    }

    out.push_str("    dependencies: [\n");

    for dep in manifest.dependencies.values() {
        out.push_str(&format_dependency(dep));
    }

    out.push_str("    ],\n");
}

fn format_dependency(dep: &Dependency) -> String {
    // Path dependency
    if let Some(path) = &dep.path {
        return format!("        .package(path: \"{}\"),\n", path.display());
    }

    // Git dependency
    if let Some(git) = &dep.git {
        // Exact revision
        if let Some(rev) = &dep.revision {
            return format!(
                "        .package(url: \"{}\", revision: \"{}\"),\n",
                git, rev
            );
        }

        // Tag (treated as "from" version for semver compatibility)
        if let Some(tag) = &dep.tag {
            // If tag looks like a version, use "from:"
            if is_semver_like(tag) {
                return format!(
                    "        .package(url: \"{}\", from: \"{}\"),\n",
                    git,
                    tag.trim_start_matches('v')
                );
            }
            // Otherwise use exact
            return format!(
                "        .package(url: \"{}\", exact: \"{}\"),\n",
                git,
                tag.trim_start_matches('v')
            );
        }

        // Branch
        if let Some(branch) = &dep.branch {
            return format!(
                "        .package(url: \"{}\", branch: \"{}\"),\n",
                git, branch
            );
        }

        // Default to main branch
        return format!("        .package(url: \"{}\", branch: \"main\"),\n", git);
    }

    // Version requirement (for registry dependencies)
    // Note: Registry dependencies are not yet fully supported in Swift PM
    // For now, we emit a comment suggesting to add a git URL
    if dep.version.is_some() {
        return format!(
            "        // Registry dependency: {} (not yet supported, add git URL)\n",
            dep.name
        );
    }

    // Fallback: comment for unsupported dependency
    format!("        // TODO: Add dependency for {}\n", dep.name)
}

fn is_semver_like(s: &str) -> bool {
    let s = s.trim_start_matches('v');
    s.chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
        && s.contains('.')
}

fn generate_targets(out: &mut String, manifest: &Manifest) {
    out.push_str("    targets: [\n");

    for target in &manifest.targets {
        generate_target(out, target, manifest);
    }

    out.push_str("    ]\n");
}

fn generate_target(out: &mut String, target: &Target, manifest: &Manifest) {
    let target_type = match target.target_type {
        TargetType::Executable => ".executableTarget",
        TargetType::Library => ".target",
        TargetType::Test => ".testTarget",
        TargetType::Plugin => ".plugin",
        TargetType::SystemLibrary => ".systemLibrary",
        TargetType::Binary => ".binaryTarget",
    };

    out.push_str(&format!("        {}(\n", target_type));
    out.push_str(&format!("            name: \"{}\"", target.name));

    // Dependencies for this target
    let target_deps: Vec<&String> = if target.dependencies.is_empty() {
        // If no explicit target deps, use all package deps for non-test targets
        if target.target_type != TargetType::Test {
            manifest.dependencies.keys().collect()
        } else {
            // Test targets depend on the main target
            let main_target = manifest.targets.iter().find(|t| {
                t.target_type == TargetType::Library || t.target_type == TargetType::Executable
            });
            if let Some(main) = main_target {
                vec![&main.name]
            } else {
                vec![]
            }
        }
    } else {
        target.dependencies.iter().collect()
    };

    if !target_deps.is_empty() {
        out.push_str(",\n            dependencies: [\n");
        for dep_name in target_deps {
            // Check if it's an internal target or external dependency
            let is_internal = manifest.targets.iter().any(|t| &t.name == dep_name);
            if is_internal {
                out.push_str(&format!("                \"{}\",\n", dep_name));
            } else {
                // External dependency - need to find product name
                out.push_str(&format!(
                    "                .product(name: \"{}\", package: \"{}\"),\n",
                    infer_product_name(dep_name),
                    infer_package_name(dep_name)
                ));
            }
        }
        out.push_str("            ]");
    }

    // Path
    if let Some(path) = &target.path {
        out.push_str(&format!(",\n            path: \"{}\"", path.display()));
    }

    // Resources
    if !target.resources.is_empty() {
        out.push_str(",\n            resources: [\n");
        for resource in &target.resources {
            out.push_str(&format!(
                "                .process(\"{}\")",
                resource.display()
            ));
        }
        out.push_str("\n            ]");
    }

    out.push_str("\n        ),\n");
}

/// Infer the product name from a dependency name.
/// e.g., "swift-log" -> "Logging", "vapor" -> "Vapor"
fn infer_product_name(dep_name: &str) -> String {
    // Common package name -> product name mappings
    match dep_name {
        "swift-log" => "Logging".to_string(),
        "swift-nio" => "NIO".to_string(),
        "swift-argument-parser" => "ArgumentParser".to_string(),
        "swift-crypto" => "Crypto".to_string(),
        "swift-collections" => "Collections".to_string(),
        "swift-algorithms" => "Algorithms".to_string(),
        "swift-atomics" => "Atomics".to_string(),
        "swift-numerics" => "Numerics".to_string(),
        "swift-system" => "SystemPackage".to_string(),
        _ => {
            // Convert kebab-case to PascalCase
            dep_name
                .split('-')
                .map(|s| {
                    let mut chars = s.chars();
                    match chars.next() {
                        None => String::new(),
                        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
                    }
                })
                .collect()
        }
    }
}

/// Infer the package name from a dependency name (usually same as dep name).
fn infer_package_name(dep_name: &str) -> String {
    dep_name.to_string()
}

/// Write a Package.swift file to the given directory.
pub fn write_package_swift(manifest: &Manifest, dir: &Path) -> std::io::Result<()> {
    let content = generate_package_swift(manifest);
    std::fs::write(dir.join("Package.swift"), content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use gust_types::{Package, Version};

    #[test]
    fn test_generate_simple_package() {
        let manifest = Manifest {
            package: Package {
                name: "MyApp".to_string(),
                version: Version::new(1, 0, 0),
                swift_tools_version: "5.9".to_string(),
                ..Default::default()
            },
            targets: vec![Target::executable("MyApp")],
            ..Default::default()
        };

        let output = generate_package_swift(&manifest);
        assert!(output.contains("swift-tools-version:5.9"));
        assert!(output.contains("name: \"MyApp\""));
        assert!(output.contains(".executableTarget"));
    }

    #[test]
    fn test_generate_with_dependencies() {
        let mut manifest = Manifest {
            package: Package {
                name: "MyApp".to_string(),
                version: Version::new(1, 0, 0),
                swift_tools_version: "5.9".to_string(),
                ..Default::default()
            },
            targets: vec![Target::executable("MyApp")],
            ..Default::default()
        };

        manifest.dependencies.insert(
            "swift-log".to_string(),
            Dependency::git("swift-log", "https://github.com/apple/swift-log.git")
                .with_tag("1.5.0"),
        );

        let output = generate_package_swift(&manifest);
        assert!(output.contains("swift-log.git"));
        assert!(output.contains("from: \"1.5.0\""));
    }

    #[test]
    fn test_generate_with_platforms() {
        let mut manifest = Manifest {
            package: Package {
                name: "MyApp".to_string(),
                version: Version::new(1, 0, 0),
                swift_tools_version: "5.9".to_string(),
                ..Default::default()
            },
            targets: vec![Target::library("MyApp")],
            ..Default::default()
        };

        manifest.platforms.insert("iOS".to_string(), "15.0".to_string());
        manifest.platforms.insert("macOS".to_string(), "12.0".to_string());

        let output = generate_package_swift(&manifest);
        assert!(output.contains("platforms: ["));
        assert!(output.contains(".iOS(.v15_0)"));
        assert!(output.contains(".macOS(.v12_0)"));
    }
}
