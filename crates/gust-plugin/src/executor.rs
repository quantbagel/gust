//! Plugin execution with optional sandboxing.
//!
//! Runs compiled plugins with appropriate permissions and sandbox constraints.

use crate::protocol::{PluginInput, PluginOutput};
use crate::{Plugin, PluginError};
use gust_types::PluginPermission;
use std::path::PathBuf;
use std::process::Stdio;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::process::Command;

/// Context for plugin execution.
#[derive(Debug, Clone)]
pub struct PluginContext {
    /// Working directory for the plugin
    pub working_directory: PathBuf,

    /// Command line arguments
    pub arguments: Vec<String>,

    /// Granted permissions
    pub permissions: Vec<PluginPermission>,
}

/// Result of plugin execution.
#[derive(Debug, Clone)]
pub struct PluginResult {
    /// Exit code
    pub exit_code: i32,

    /// Standard output
    pub stdout: String,

    /// Standard error
    pub stderr: String,

    /// Structured output from plugin protocol
    pub output: Option<PluginOutput>,

    /// Files generated by the plugin
    pub generated_files: Vec<PathBuf>,
}

/// Plugin executor with optional sandboxing.
pub struct PluginExecutor {
    /// Whether to use sandbox
    use_sandbox: bool,
}

impl PluginExecutor {
    /// Create a new plugin executor.
    pub fn new(use_sandbox: bool) -> Self {
        Self { use_sandbox }
    }

    /// Execute a plugin with the given context.
    pub async fn execute(
        &self,
        plugin: &Plugin,
        context: PluginContext,
    ) -> Result<PluginResult, PluginError> {
        let mut cmd = if self.use_sandbox {
            self.create_sandboxed_command(plugin, &context)?
        } else {
            self.create_command(plugin, &context)
        };

        // Set up stdin/stdout for protocol communication
        cmd.stdin(Stdio::piped());
        cmd.stdout(Stdio::piped());
        cmd.stderr(Stdio::piped());

        let mut child = cmd.spawn().map_err(|e| {
            PluginError::ExecutionFailed(format!("Failed to spawn plugin: {}", e))
        })?;

        // Send input to plugin via stdin
        if let Some(mut stdin) = child.stdin.take() {
            let input = PluginInput {
                working_directory: context.working_directory.clone(),
                arguments: context.arguments.clone(),
            };
            let json = serde_json::to_string(&input)?;
            stdin.write_all(json.as_bytes()).await?;
            stdin.write_all(b"\n").await?;
            stdin.flush().await?;
        }

        // Collect output
        let mut stdout_lines = Vec::new();
        let mut stderr_lines = Vec::new();

        if let Some(stdout) = child.stdout.take() {
            let mut reader = BufReader::new(stdout).lines();
            while let Ok(Some(line)) = reader.next_line().await {
                stdout_lines.push(line);
            }
        }

        if let Some(stderr) = child.stderr.take() {
            let mut reader = BufReader::new(stderr).lines();
            while let Ok(Some(line)) = reader.next_line().await {
                stderr_lines.push(line);
            }
        }

        let status = child.wait().await.map_err(|e| {
            PluginError::ExecutionFailed(format!("Failed to wait for plugin: {}", e))
        })?;

        // Try to parse structured output from last stdout line
        let output = stdout_lines
            .last()
            .and_then(|line| serde_json::from_str::<PluginOutput>(line).ok());

        // Extract generated files from output
        let generated_files = output
            .as_ref()
            .map(|o| o.generated_files.clone())
            .unwrap_or_default();

        Ok(PluginResult {
            exit_code: status.code().unwrap_or(-1),
            stdout: stdout_lines.join("\n"),
            stderr: stderr_lines.join("\n"),
            output,
            generated_files,
        })
    }

    /// Create a command without sandboxing.
    fn create_command(&self, plugin: &Plugin, context: &PluginContext) -> Command {
        let mut cmd = Command::new(&plugin.executable);
        cmd.current_dir(&context.working_directory);
        cmd.args(&context.arguments);
        cmd
    }

    /// Create a sandboxed command.
    ///
    /// On macOS, uses sandbox-exec.
    /// On Linux, would use seccomp/bubblewrap (not implemented).
    fn create_sandboxed_command(
        &self,
        plugin: &Plugin,
        context: &PluginContext,
    ) -> Result<Command, PluginError> {
        #[cfg(target_os = "macos")]
        {
            let sandbox_profile = self.generate_macos_sandbox_profile(plugin, context)?;
            let mut cmd = Command::new("sandbox-exec");
            cmd.arg("-p").arg(sandbox_profile);
            cmd.arg(&plugin.executable);
            cmd.current_dir(&context.working_directory);
            cmd.args(&context.arguments);
            Ok(cmd)
        }

        #[cfg(not(target_os = "macos"))]
        {
            // On other platforms, fall back to unsandboxed execution
            // Real implementation would use seccomp or bubblewrap on Linux
            tracing::warn!("Sandboxing not available on this platform, running unsandboxed");
            Ok(self.create_command(plugin, context))
        }
    }

    /// Generate a macOS sandbox profile based on permissions.
    #[cfg(target_os = "macos")]
    fn generate_macos_sandbox_profile(
        &self,
        _plugin: &Plugin,
        context: &PluginContext,
    ) -> Result<String, PluginError> {
        use gust_types::NetworkScope;

        let mut profile = String::from("(version 1)\n");
        profile.push_str("(deny default)\n");

        // Basic permissions
        profile.push_str("(allow process-exec)\n");
        profile.push_str("(allow file-read*)\n");

        // Check granted permissions
        for permission in &context.permissions {
            match permission {
                PluginPermission::WriteToPackageDirectory { .. } => {
                    profile.push_str(&format!(
                        "(allow file-write* (subpath \"{}\"))\n",
                        context.working_directory.display()
                    ));
                }
                PluginPermission::AllowNetworkConnections { scope, .. } => {
                    match scope {
                        NetworkScope::All => {
                            profile.push_str("(allow network*)\n");
                        }
                        NetworkScope::Local(port) => {
                            profile.push_str(&format!(
                                "(allow network-outbound (local ip \"*:{}\"))\n",
                                port
                            ));
                        }
                        NetworkScope::Docker => {
                            // Docker socket access
                            profile.push_str("(allow network-outbound (to unix-socket \"/var/run/docker.sock\"))\n");
                        }
                        NetworkScope::None => {
                            // No network access (default deny)
                        }
                    }
                }
            }
        }

        Ok(profile)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plugin_context() {
        let context = PluginContext {
            working_directory: PathBuf::from("/workspace"),
            arguments: vec!["--verbose".to_string()],
            permissions: vec![],
        };

        assert_eq!(context.working_directory, PathBuf::from("/workspace"));
        assert_eq!(context.arguments, vec!["--verbose"]);
    }
}
